// Generated by CoffeeScript 1.4.0
var GameState, Map, cubeData, height, renderer, stats, width;

cubeData = ["G G D D D D G G\nG G D D D D G G\nD D D D D D D D\nD D D D D D D D\nD D D D D D D D\nD D D D D D D D\nG G D D D D G G\nG G D D D D G G", "- - - - - - - P\n- - P - - - - -\n- - - W - - P -\n- - - - - P - -\n- P - - - - - -\n- - - - P - - -\n- - - P - - - -\nP - - - - - - -", "- - - - - - - -\n- - - - - - - -\n- - - W - - - -\n- - - - - - - -\n- - - - - - - -\n- - - - - - - -\n- - - - - - - -\n- - - - - - - -"].map(function(plane) {
  return plane.split("\n").map(function(row) {
    return row.split(" ");
  });
});

Map = function(I) {
  var findTextures, init, materials, n, testImageUrl, textureLookup, textures;
  if (I == null) {
    I = {};
  }
  Object.defaults(I, {
    x: App.width / 2,
    y: App.height / 2,
    height: App.height,
    width: App.width,
    size: 8
  });
  findTextures = function(key) {
    if (key === '-') {
      return;
    }
    return [].concat(textureLookup[key]).map(function(textureIndex) {
      return materials[textureIndex];
    }).wrap(0, 6);
  };
  textureLookup = {
    D: 2,
    G: [77, 77, 78, 2, 77, 77],
    P: [118, 118, 102, 118, 119, 118],
    W: [20, 20, 21, 21, 20, 20]
  };
  testImageUrl = ResourceLoader.urlFor("images", "terrain");
  textures = [];
  materials = [];
  n = 16;
  n.times(function(y) {
    return n.times(function(x) {
      var texture;
      texture = THREE.ImageUtils.loadTexture(testImageUrl);
      texture.offset.x = (1 / n) * x;
      texture.offset.y = (1 / n) * ((n - 1) - y);
      texture.repeat.x = 1 / n;
      texture.repeat.y = 1 / n;
      return textures.push(texture);
    });
  });
  init = function() {
    materials = textures.map(function(texture) {
      return new THREE.MeshBasicMaterial({
        wireframe: false,
        map: texture
      });
    });
    return cubeData.each(function(plane, y) {
      return plane.each(function(row, z) {
        return row.each(function(c, x) {
          var cube, geometry, surfaceTextures;
          if (surfaceTextures = findTextures(c)) {
            geometry = new THREE.CubeGeometry(I.size, I.size, I.size, 1, 1, 1);
            cube = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(surfaceTextures));
            cube.position.y = I.size * (y - 4);
            cube.position.x = I.size * (x - 4);
            cube.position.z = I.size * (z - 4);
            return engine.scene().add(cube);
          }
        });
      });
    });
  };
  return init();
};

GameObject.ThreeD = function(I, self) {
  if (I == null) {
    I = {};
  }
  Object.defaults(I, {
    size: 10
  });
  self.on('update', function() {
    I.mesh.geometry.vertices[0].set(I.x, I.y, I.z);
    return I.mesh.geometry.verticesNeedUpdate = true;
  });
  return {
    mesh: function() {
      var material, texture;
      texture = THREE.ImageUtils.loadTexture(ResourceLoader.urlFor("images", I.spriteName));
      material = new THREE.ParticleBasicMaterial({
        size: I.size,
        depthFalse: false,
        transparent: true,
        map: texture
      });
      I.geometry = new THREE.Geometry();
      I.geometry.vertices.push(new THREE.Vector3(I.x, I.y, I.z));
      I.mesh = new THREE.ParticleSystem(I.geometry, material);
      return I.mesh;
    }
  };
};

GameState = function(I) {
  var queuedObjects, self;
  if (I == null) {
    I = {};
  }
  Object.reverseMerge(I, {
    objects: []
  });
  queuedObjects = [];
  self = Core(I).extend({
    /**
    The add method creates and adds an object to the game world. Two
    other events are triggered around this one: beforeAdd and afterAdd.
    
        # you can add arbitrary entityData and
        # the engine will make it into a GameObject
        engine.add 
          x: 50
          y: 30
          color: "red"
    
        player = engine.add
          class: "Player"
    
    @name add
    @methodOf Engine#
    @param {Object} entityData The data used to create the game object.
    @returns {GameObject}
    */

    add: function(entityData) {
      var object;
      self.trigger("beforeAdd", entityData);
      object = GameObject.construct(entityData);
      object.create();
      self.trigger("afterAdd", object);
      if (I.updating) {
        queuedObjects.push(object);
      } else {
        I.objects.push(object);
      }
      return object;
    },
    objects: function() {
      return I.objects.copy();
    }
  });
  self.bind("update", function(elapsedTime) {
    var toKeep, toRemove, _ref;
    I.updating = true;
    I.objects.invoke("trigger", "beforeUpdate", elapsedTime);
    _ref = I.objects.partition(function(object) {
      return object.update(elapsedTime);
    }), toKeep = _ref[0], toRemove = _ref[1];
    I.objects.invoke("trigger", "afterUpdate", elapsedTime);
    toRemove.invoke("trigger", "remove");
    I.objects = toKeep.concat(queuedObjects);
    queuedObjects = [];
    return I.updating = false;
  });
  self.include("GameState.ThreeD");
  return self;
};

GameState.ThreeD = function(I, self) {
  var camera, cameraTarget, height, scene, width;
  if (I == null) {
    I = {};
  }
  width = App.width, height = App.height;
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, width / height, 1, 10000);
  camera.position.z = 100;
  camera.position.y = 25;
  camera.position.x = 0;
  cameraTarget = new THREE.Vector3(0, 0, 0);
  self.on("draw", function(canvas) {
    return canvas.render(scene, camera);
  });
  self.on('afterAdd', function(obj) {
    return scene.add(obj.mesh());
  });
  self.bind("update", function() {
    return camera.lookAt(cameraTarget);
  });
  return {
    pan: function(delta) {
      return ["x", "y", "z"].each(function(d) {
        camera.position[d] += delta[d];
        return cameraTarget[d] += delta[d];
      });
    },
    scene: scene
  };
};

GameObject.defaultModules = GameObject.defaultModules.without(['Drawable']).concat(['GameObject.ThreeD']);

stats = xStats({
  width: 200,
  height: 130
});

$(stats.element).css({
  position: "absolute",
  right: 0,
  top: 0
}).appendTo("body");

width = App.width, height = App.height;

renderer = new THREE.WebGLRenderer({
  antialias: true,
  canvas: $('canvas').get(0)
});

renderer.setSize(width, height);

Engine.defaultModules.push("Gamepads");

window.engine = Engine({
  canvas: renderer,
  clear: false,
  backgroundColor: null
});

engine.start();

engine.on("update", function(dt) {
  var cameraSpeed, p;
  cameraSpeed = 100;
  p = engine.controller(0).position(1).scale(cameraSpeed * dt);
  return engine.pan({
    x: p.x,
    y: 0,
    z: p.y
  });
});

engine.scene = function() {
  return engine.I.currentState.scene;
};

engine.pan = function(delta) {
  return engine.I.currentState.pan(delta);
};

Map();
